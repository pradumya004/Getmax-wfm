// backend/src/models/sla/slaReporting.model.js

import mongoose from 'mongoose';
// import crypto from 'crypto';
import { SLA_CONSTANTS } from '../../utils/constants.js';
import { scopedIdPlugin } from '../../plugins/scopedIdPlugin.js';

const slaReportingSchema = new mongoose.Schema({
    // ** UNIQUE IDENTIFIERS **
    reportId: {
        type: String,
        unique: true,
        // default: () => `SLAR-${crypto.randomBytes(4).toString('hex').toUpperCase()}`,
        immutable: true,
        index: true
    },

    // ** CORE RELATIONSHIPS **
    companyRef: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Company',
        required: [true, 'Company reference is required'],
        index: true
    },

    generatedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Employee',
        required: [true, 'Generated by employee is required']
    },

    // ** REPORT CONFIGURATION **
    reportConfig: {
        reportName: {
            type: String,
            required: [true, 'Report name is required'],
            trim: true,
            maxlength: [100, 'Report name cannot exceed 100 characters']
        },
        reportType: {
            type: String,
            required: [true, 'Report type is required'],
            enum: {
                values: [
                    'COMPLIANCE_SUMMARY', 'VIOLATION_ANALYSIS', 'TREND_REPORT',
                    'EMPLOYEE_PERFORMANCE', 'SERVICE_PERFORMANCE', 'EXECUTIVE_DASHBOARD',
                    'DETAILED_ANALYTICS', 'BENCHMARK_COMPARISON', 'ESCALATION_REPORT'
                ],
                message: 'Invalid report type'
            },
            index: true
        },
        reportScope: {
            type: String,
            required: [true, 'Report scope is required'],
            enum: {
                values: ['COMPANY_WIDE', 'DEPARTMENT', 'TEAM', 'INDIVIDUAL', 'SERVICE_TYPE', 'CLIENT_SPECIFIC'],
                message: 'Invalid report scope'
            }
        },
        description: {
            type: String,
            trim: true,
            maxlength: [500, 'Description cannot exceed 500 characters']
        }
    },

    // ** REPORT PERIOD **
    reportPeriod: {
        periodType: {
            type: String,
            required: [true, 'Period type is required'],
            enum: {
                values: ['DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY', 'YEARLY', 'CUSTOM'],
                message: 'Invalid period type'
            }
        },
        startDate: {
            type: Date,
            required: [true, 'Start date is required'],
            index: true
        },
        endDate: {
            type: Date,
            required: [true, 'End date is required'],
            index: true
        },
        timezone: {
            type: String,
            default: 'EST'
        },

        // Comparison Periods
        comparisonPeriods: [{
            periodName: String,
            startDate: Date,
            endDate: Date,
            isBaseline: {
                type: Boolean,
                default: false
            }
        }]
    },

    // ** FILTERS & CRITERIA **
    filterCriteria: {
        slaRefs: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'SLA'
        }],
        employeeRefs: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Employee'
        }],
        departmentRefs: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Department'
        }],
        serviceTypes: [{
            type: String,
            enum: [
                'AR_CALLING', 'MEDICAL_CODING', 'PRIOR_AUTH', 'DENIAL_MANAGEMENT',
                'PATIENT_REGISTRATION', 'INSURANCE_VERIFICATION', 'PAYMENT_POSTING',
                'CLAIMS_PROCESSING'
            ]
        }],
        severityLevels: [{
            type: String,
            enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']
        }],
        violationTypes: [String],

        // Advanced Filters
        customFilters: [{
            field: String,
            operator: {
                type: String,
                enum: ['EQUALS', 'NOT_EQUALS', 'GREATER_THAN', 'LESS_THAN', 'CONTAINS', 'BETWEEN']
            },
            value: mongoose.Schema.Types.Mixed
        }]
    },

    // ** REPORT METRICS **
    reportMetrics: {
        // Overall SLA Performance
        overallMetrics: {
            totalSLAs: {
                type: Number,
                default: 0,
                min: [0, 'Total SLAs cannot be negative']
            },
            totalInstances: {
                type: Number,
                default: 0,
                min: [0, 'Total instances cannot be negative']
            },
            metInstances: {
                type: Number,
                default: 0,
                min: [0, 'Met instances cannot be negative']
            },
            violatedInstances: {
                type: Number,
                default: 0,
                min: [0, 'Violated instances cannot be negative']
            },
            complianceRate: {
                type: Number,
                min: [0, 'Compliance rate cannot be negative'],
                max: [100, 'Compliance rate cannot exceed 100'],
                default: 0
            },
            averagePerformance: {
                type: Number,
                min: [0, 'Average performance cannot be negative'],
                default: 0
            }
        },

        // Performance by Category
        categoryMetrics: [{
            category: {
                type: String,
                enum: [
                    'PERFORMANCE', 'QUALITY', 'AVAILABILITY', 'RESPONSIVENESS',
                    'PROCESS_COMPLIANCE', 'CUSTOMER_SERVICE'
                ]
            },
            totalInstances: Number,
            metInstances: Number,
            violatedInstances: Number,
            complianceRate: Number,
            averagePerformance: Number
        }],

        // Performance by Service Type
        serviceTypeMetrics: [{
            serviceType: {
                type: String,
                enum: [
                    'AR_CALLING', 'MEDICAL_CODING', 'PRIOR_AUTH', 'DENIAL_MANAGEMENT',
                    'PATIENT_REGISTRATION', 'INSURANCE_VERIFICATION', 'PAYMENT_POSTING',
                    'CLAIMS_PROCESSING'
                ]
            },
            totalSLAs: Number,
            totalInstances: Number,
            metInstances: Number,
            violatedInstances: Number,
            complianceRate: Number,
            averageResponseTime: Number,
            criticalViolations: Number
        }],

        // Employee Performance
        employeeMetrics: [{
            employeeRef: {
                type: mongoose.Schema.Types.ObjectId,
                ref: 'Employee'
            },
            totalSLAs: Number,
            totalInstances: Number,
            metInstances: Number,
            violatedInstances: Number,
            complianceRate: Number,
            averagePerformance: Number,
            rank: Number,
            grade: {
                type: String,
                enum: ['A', 'B', 'C', 'D', 'F']
            }
        }],

        // Violation Analysis
        violationMetrics: {
            totalViolations: Number,
            violationsByType: [{
                violationType: String,
                count: Number,
                percentage: Number
            }],
            violationsBySeverity: [{
                severity: {
                    type: String,
                    enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']
                },
                count: Number,
                percentage: Number
            }],
            recurringViolations: Number,
            escalatedViolations: Number,
            unresolvedViolations: Number,
            averageResolutionTime: Number
        }
    },

    // ** TREND ANALYSIS **
    trendAnalysis: {
        complianceTrend: {
            direction: {
                type: String,
                enum: ['IMPROVING', 'STABLE', 'DECLINING'],
                default: 'STABLE'
            },
            changeRate: Number,
            periodComparison: [{
                period: String,
                value: Number,
                change: Number,
                changePercentage: Number
            }]
        },

        violationTrends: {
            direction: {
                type: String,
                enum: ['IMPROVING', 'STABLE', 'DECLINING'],
                default: 'STABLE'
            },
            changeRate: Number,
            trendData: [{
                date: Date,
                violationCount: Number,
                complianceRate: Number
            }]
        },

        performanceTrends: {
            topPerformers: [{
                employeeRef: {
                    type: mongoose.Schema.Types.ObjectId,
                    ref: 'Employee'
                },
                complianceRate: Number,
                improvement: Number
            }],
            bottomPerformers: [{
                employeeRef: {
                    type: mongoose.Schema.Types.ObjectId,
                    ref: 'Employee'
                },
                complianceRate: Number,
                decline: Number
            }],
            consistentPerformers: [{
                employeeRef: {
                    type: mongoose.Schema.Types.ObjectId,
                    ref: 'Employee'
                },
                consistency: Number,
                varianceScore: Number
            }]
        }
    },

    // ** BENCHMARK DATA **
    benchmarkData: {
        industryBenchmarks: {
            averageCompliance: Number,
            topQuartileCompliance: Number,
            medianCompliance: Number,
            bottomQuartileCompliance: Number
        },

        companyPosition: {
            percentileRank: Number,
            benchmarkCategory: {
                type: String,
                enum: ['TOP_PERFORMER', 'ABOVE_AVERAGE', 'AVERAGE', 'BELOW_AVERAGE', 'NEEDS_IMPROVEMENT']
            },
            gapAnalysis: {
                complianceGap: Number,
                performanceGap: Number,
                timeToTarget: Number
            }
        },

        competitiveAnalysis: {
            peerComparison: [{
                metric: String,
                companyValue: Number,
                peerAverage: Number,
                ranking: Number,
                totalPeers: Number
            }]
        }
    },

    // ** INSIGHTS & RECOMMENDATIONS **
    insights: {
        keyFindings: [{
            finding: {
                type: String,
                required: true,
                trim: true
            },
            impact: {
                type: String,
                enum: ['HIGH', 'MEDIUM', 'LOW'],
                default: 'MEDIUM'
            },
            category: {
                type: String,
                enum: ['POSITIVE', 'NEGATIVE', 'NEUTRAL'],
                default: 'NEUTRAL'
            },
            supportingData: mongoose.Schema.Types.Mixed
        }],

        recommendations: [{
            recommendation: {
                type: String,
                required: true,
                trim: true
            },
            priority: {
                type: String,
                enum: ['HIGH', 'MEDIUM', 'LOW'],
                default: 'MEDIUM'
            },
            category: {
                type: String,
                enum: [
                    'PROCESS_IMPROVEMENT', 'TRAINING', 'RESOURCE_ALLOCATION',
                    'POLICY_CHANGE', 'SYSTEM_ENHANCEMENT', 'PERFORMANCE_MANAGEMENT'
                ]
            },
            estimatedImpact: {
                type: String,
                enum: ['HIGH', 'MEDIUM', 'LOW']
            },
            implementationEffort: {
                type: String,
                enum: ['HIGH', 'MEDIUM', 'LOW']
            },
            timeframe: String,
            responsible: [{
                type: mongoose.Schema.Types.ObjectId,
                ref: 'Employee'
            }]
        }],

        riskAreas: [{
            area: String,
            riskLevel: {
                type: String,
                enum: ['HIGH', 'MEDIUM', 'LOW'],
                default: 'MEDIUM'
            },
            description: String,
            mitigationActions: [String]
        }],

        opportunities: [{
            opportunity: String,
            potential: {
                type: String,
                enum: ['HIGH', 'MEDIUM', 'LOW']
            },
            description: String,
            actionItems: [String]
        }]
    },

    // ** REPORT OUTPUT **
    reportOutput: {
        formatType: {
            type: String,
            enum: ['PDF', 'EXCEL', 'JSON', 'CSV', 'HTML'],
            default: 'PDF'
        },
        filePath: String,
        fileSize: Number,
        chartImages: [{
            chartType: String,
            imagePath: String,
            description: String
        }],

        executiveSummary: {
            type: String,
            trim: true,
            maxlength: [5000, 'Executive summary cannot exceed 5000 characters']
        },

        detailedAnalysis: {
            type: String,
            trim: true
        },

        actionPlan: {
            type: String,
            trim: true
        }
    },

    // ** DISTRIBUTION & SHARING **
    distributionInfo: {
        recipients: [{
            employeeRef: {
                type: mongoose.Schema.Types.ObjectId,
                ref: 'Employee'
            },
            deliveryMethod: {
                type: String,
                enum: ['EMAIL', 'IN_APP', 'DOWNLOAD', 'SHARED_FOLDER'],
                default: 'EMAIL'
            },
            deliveredAt: Date,
            downloadedAt: Date,
            viewedAt: Date
        }],

        shareSettings: {
            isPublic: {
                type: Boolean,
                default: false
            },
            allowDownload: {
                type: Boolean,
                default: true
            },
            expiryDate: Date,
            accessCode: String
        },

        scheduledDistribution: {
            isScheduled: {
                type: Boolean,
                default: false
            },
            frequency: {
                type: String,
                enum: ['DAILY', 'WEEKLY', 'MONTHLY', 'QUARTERLY']
            },
            nextDelivery: Date,
            lastDelivery: Date
        }
    },

    // ** GENERATION METADATA **
    generationInfo: {
        generatedAt: {
            type: Date,
            required: [true, 'Generation time is required'],
            default: Date.now
        },
        generationMethod: {
            type: String,
            enum: ['MANUAL', 'SCHEDULED', 'API_TRIGGERED', 'AUTOMATED'],
            default: 'MANUAL'
        },
        processingTime: {
            type: Number, // milliseconds
            min: [0, 'Processing time cannot be negative']
        },
        dataSourcesUsed: [{
            source: String,
            recordCount: Number,
            dateRange: {
                start: Date,
                end: Date
            }
        }],

        calculationDetails: {
            totalRecordsProcessed: Number,
            calculationEngine: String,
            version: String,
            parameters: mongoose.Schema.Types.Mixed
        }
    },

    // ** STATUS & LIFECYCLE **
    statusInfo: {
        status: {
            type: String,
            required: [true, 'Status is required'],
            enum: {
                values: ['GENERATING', 'COMPLETED', 'FAILED', 'CANCELLED', 'ARCHIVED'],
                message: 'Invalid status'
            },
            default: 'GENERATING',
            index: true
        },
        isArchived: {
            type: Boolean,
            default: false
        },
        archivedAt: Date,
        archivedBy: {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Employee'
        },

        // Error Information
        errors: [{
            errorCode: String,
            errorMessage: String,
            timestamp: {
                type: Date,
                default: Date.now
            },
            severity: {
                type: String,
                enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
                default: 'MEDIUM'
            }
        }]
    }
}, {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// ** INDEXES **
slaReportingSchema.index({ companyRef: 1, 'reportConfig.reportType': 1 });
slaReportingSchema.index({ 'reportPeriod.startDate': 1, 'reportPeriod.endDate': 1 });
slaReportingSchema.index({ generatedBy: 1, 'generationInfo.generatedAt': -1 });
slaReportingSchema.index({ 'statusInfo.status': 1, 'statusInfo.isArchived': 1 });
slaReportingSchema.index({ 'distributionInfo.scheduledDistribution.nextDelivery': 1 });

// ** VIRTUALS **
slaReportingSchema.virtual('reportAge').get(function () {
    return this.generationInfo?.generatedAt ?
        Math.floor((new Date() - this.generationInfo.generatedAt) / (1000 * 60 * 60 * 24)) : 0;
});

slaReportingSchema.virtual('isStale').get(function () {
    const ageInDays = this.reportAge;
    const staleThresholds = {
        'DAILY': 2,
        'WEEKLY': 8,
        'MONTHLY': 32,
        'QUARTERLY': 95
    };

    return ageInDays > (staleThresholds[this.reportPeriod?.periodType] || 30);
});

slaReportingSchema.virtual('overallGrade').get(function () {
    const compliance = this.reportMetrics?.overallMetrics?.complianceRate || 0;
    if (compliance >= 95) return 'A';
    if (compliance >= 90) return 'B';
    if (compliance >= 80) return 'C';
    if (compliance >= 70) return 'D';
    return 'F';
});

slaReportingSchema.virtual('executiveSummaryPoints').get(function () {
    const points = [];
    const metrics = this.reportMetrics?.overallMetrics;

    if (metrics?.complianceRate >= 95) {
        points.push('Excellent SLA compliance achieved');
    } else if (metrics?.complianceRate < 80) {
        points.push('SLA compliance below target - immediate attention required');
    }

    if (this.reportMetrics?.violationMetrics?.recurringViolations > 5) {
        points.push('High number of recurring violations identified');
    }

    if (this.trendAnalysis?.complianceTrend?.direction === 'IMPROVING') {
        points.push('Positive compliance trend observed');
    } else if (this.trendAnalysis?.complianceTrend?.direction === 'DECLINING') {
        points.push('Declining compliance trend - action needed');
    }

    return points;
});

// ** STATIC METHODS **
slaReportingSchema.statics.findByType = function (companyId, reportType, limit = 10) {
    return this.find({
        companyRef: companyId,
        'reportConfig.reportType': reportType,
        'statusInfo.status': 'COMPLETED',
        'statusInfo.isArchived': false
    })
        .populate('generatedBy', 'firstName lastName')
        .sort({ 'generationInfo.generatedAt': -1 })
        .limit(limit);
};

slaReportingSchema.statics.findScheduledReports = function (dueDate = new Date()) {
    return this.find({
        'distributionInfo.scheduledDistribution.isScheduled': true,
        'distributionInfo.scheduledDistribution.nextDelivery': { $lte: dueDate },
        'statusInfo.status': { $ne: 'ARCHIVED' }
    }).populate('companyRef generatedBy distributionInfo.recipients.employeeRef');
};

slaReportingSchema.statics.getReportingMetrics = function (companyId, startDate, endDate) {
    return this.aggregate([
        {
            $match: {
                companyRef: new mongoose.Types.ObjectId(companyId),
                'generationInfo.generatedAt': {
                    $gte: startDate,
                    $lte: endDate
                }
            }
        },
        {
            $group: {
                _id: '$reportConfig.reportType',
                totalReports: { $sum: 1 },
                completedReports: {
                    $sum: { $cond: [{ $eq: ['$statusInfo.status', 'COMPLETED'] }, 1, 0] }
                },
                failedReports: {
                    $sum: { $cond: [{ $eq: ['$statusInfo.status', 'FAILED'] }, 1, 0] }
                },
                avgProcessingTime: { $avg: '$generationInfo.processingTime' },
                avgComplianceRate: { $avg: '$reportMetrics.overallMetrics.complianceRate' }
            }
        },
        {
            $project: {
                reportType: '$_id',
                totalReports: 1,
                completedReports: 1,
                failedReports: 1,
                successRate: {
                    $round: [
                        { $multiply: [{ $divide: ['$completedReports', '$totalReports'] }, 100] },
                        2
                    ]
                },
                avgProcessingTimeSeconds: {
                    $round: [{ $divide: ['$avgProcessingTime', 1000] }, 2]
                },
                avgComplianceRate: { $round: ['$avgComplianceRate', 2] }
            }
        }
    ]);
};

// ** INSTANCE METHODS **
slaReportingSchema.methods.generateExecutiveSummary = function () {
    const metrics = this.reportMetrics?.overallMetrics;
    const violations = this.reportMetrics?.violationMetrics;
    const trend = this.trendAnalysis?.complianceTrend;

    let summary = `SLA Compliance Report for ${this.reportPeriod?.periodType?.toLowerCase()} period `;
    summary += `from ${this.reportPeriod?.startDate?.toDateString()} to ${this.reportPeriod?.endDate?.toDateString()}.\n\n`;

    if (metrics) {
        summary += `Overall compliance rate: ${metrics.complianceRate}% `;
        summary += `(${metrics.metInstances} of ${metrics.totalInstances} instances met SLA targets).\n`;
    }

    if (violations) {
        summary += `Total violations: ${violations.totalViolations}, `;
        summary += `with ${violations.escalatedViolations} requiring escalation.\n`;
    }

    if (trend) {
        summary += `Compliance trend: ${trend.direction?.toLowerCase()}.`;
        if (trend.changeRate) {
            summary += ` Change rate: ${trend.changeRate > 0 ? '+' : ''}${trend.changeRate}%.\n`;
        }
    }

    this.reportOutput.executiveSummary = summary;
    return this.save();
};

slaReportingSchema.methods.addRecommendation = function (recommendation, priority = 'MEDIUM', category) {
    this.insights.recommendations.push({
        recommendation,
        priority,
        category,
        estimatedImpact: 'MEDIUM',
        implementationEffort: 'MEDIUM'
    });

    return this.save();
};

slaReportingSchema.methods.distributeReport = function (recipients, deliveryMethod = 'EMAIL') {
    recipients.forEach(employeeRef => {
        this.distributionInfo.recipients.push({
            employeeRef,
            deliveryMethod,
            deliveredAt: new Date()
        });
    });

    return this.save();
};

slaReportingSchema.methods.scheduleDistribution = function (frequency, nextDelivery) {
    this.distributionInfo.scheduledDistribution = {
        isScheduled: true,
        frequency,
        nextDelivery,
        lastDelivery: this.generationInfo?.generatedAt
    };

    return this.save();
};

slaReportingSchema.methods.archive = function (archivedBy) {
    this.statusInfo.isArchived = true;
    this.statusInfo.archivedAt = new Date();
    this.statusInfo.archivedBy = archivedBy;

    return this.save();
};

slaReportingSchema.methods.calculateComplianceScore = function () {
    const metrics = this.reportMetrics?.overallMetrics;
    if (!metrics) return 0;

    let score = metrics.complianceRate || 0;

    // Bonus for high performance
    if (score >= 95) score += 5;
    else if (score >= 90) score += 2;

    // Penalty for violations
    const violations = this.reportMetrics?.violationMetrics;
    if (violations?.criticalViolations > 0) score -= violations.criticalViolations * 2;
    if (violations?.recurringViolations > 5) score -= 5;

    // Trend adjustment
    const trend = this.trendAnalysis?.complianceTrend;
    if (trend?.direction === 'IMPROVING') score += 3;
    else if (trend?.direction === 'DECLINING') score -= 3;

    return Math.max(0, Math.min(100, score));
};

// ** PLUGINS **
slaReportingSchema.plugin(scopedIdPlugin, {
    idField: 'reportId',
    prefix: 'SLA-RPT',
    companyRefPath: 'companyRef'
})

// ** MIDDLEWARE **
slaReportingSchema.pre('save', function (next) {
    // Calculate processing time if completed
    if (this.statusInfo?.status === 'COMPLETED' && !this.generationInfo?.processingTime) {
        const start = this.generationInfo?.generatedAt || this.createdAt;
        this.generationInfo.processingTime = Date.now() - start.getTime();
    }

    // Validate period consistency
    if (this.reportPeriod?.startDate && this.reportPeriod?.endDate) {
        if (this.reportPeriod.startDate >= this.reportPeriod.endDate) {
            next(new Error('Start date must be before end date'));
            return;
        }
    }

    next();
});

export const SLAReporting = mongoose.model('SLAReporting', slaReportingSchema, 'slaReportings');